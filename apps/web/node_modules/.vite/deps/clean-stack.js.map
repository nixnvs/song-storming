{
  "version": 3,
  "sources": ["../../clean-stack/node_modules/escape-string-regexp/index.js", "../../clean-stack/home-directory-browser.js", "../../clean-stack/index.js"],
  "sourcesContent": ["export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n", "const getHomeDirectory = () => '';\n\nexport default getHomeDirectory;\n", "import escapeStringRegexp from 'escape-string-regexp';\nimport getHomeDirectory from '#home-directory';\n\nconst extractPathRegex = /\\s+at.*[(\\s](.*)\\)?/;\nconst pathRegex = /^(?:(?:(?:node|node:[\\w/]+|(?:(?:node:)?internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)(?:\\.js)?:\\d+:\\d+)|native)/;\n\nexport default function cleanStack(stack, {pretty = false, basePath, pathFilter} = {}) {\n\tconst basePathRegex = basePath && new RegExp(`(file://)?${escapeStringRegexp(basePath.replace(/\\\\/g, '/'))}/?`, 'g');\n\tconst homeDirectory = pretty ? getHomeDirectory() : '';\n\n\tif (typeof stack !== 'string') {\n\t\treturn undefined;\n\t}\n\n\treturn stack.replace(/\\\\/g, '/')\n\t\t.split('\\n')\n\t\t.filter(line => {\n\t\t\tconst pathMatches = line.match(extractPathRegex);\n\t\t\tif (pathMatches === null || !pathMatches[1]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst match = pathMatches[1];\n\n\t\t\t// Electron\n\t\t\tif (\n\t\t\t\tmatch.includes('.app/Contents/Resources/electron.asar')\n\t\t\t\t|| match.includes('.app/Contents/Resources/default_app.asar')\n\t\t\t\t|| match.includes('node_modules/electron/dist/resources/electron.asar')\n\t\t\t\t|| match.includes('node_modules/electron/dist/resources/default_app.asar')\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn pathFilter\n\t\t\t\t? !pathRegex.test(match) && pathFilter(match)\n\t\t\t\t: !pathRegex.test(match);\n\t\t})\n\t\t.filter(line => line.trim() !== '')\n\t\t.map(line => {\n\t\t\tif (basePathRegex) {\n\t\t\t\tline = line.replace(basePathRegex, '');\n\t\t\t}\n\n\t\t\tif (pretty) {\n\t\t\t\tline = line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDirectory, '~')));\n\t\t\t}\n\n\t\t\treturn line;\n\t\t})\n\t\t.join('\\n');\n}\n"],
  "mappings": ";;;AAAe,SAAR,mBAAoC,QAAQ;AAClD,MAAI,OAAO,WAAW,UAAU;AAC/B,UAAM,IAAI,UAAU,mBAAmB;AAAA,EACxC;AAIA,SAAO,OACL,QAAQ,uBAAuB,MAAM,EACrC,QAAQ,MAAM,OAAO;AACxB;;;ACVA,IAAM,mBAAmB,MAAM;AAE/B,IAAO,iCAAQ;;;ACCf,IAAM,mBAAmB;AACzB,IAAM,YAAY;AAEH,SAAR,WAA4B,OAAO,EAAC,SAAS,OAAO,UAAU,WAAU,IAAI,CAAC,GAAG;AACtF,QAAM,gBAAgB,YAAY,IAAI,OAAO,aAAa,mBAAmB,SAAS,QAAQ,OAAO,GAAG,CAAC,CAAC,MAAM,GAAG;AACnH,QAAM,gBAAgB,SAAS,+BAAiB,IAAI;AAEpD,MAAI,OAAO,UAAU,UAAU;AAC9B,WAAO;AAAA,EACR;AAEA,SAAO,MAAM,QAAQ,OAAO,GAAG,EAC7B,MAAM,IAAI,EACV,OAAO,UAAQ;AACf,UAAM,cAAc,KAAK,MAAM,gBAAgB;AAC/C,QAAI,gBAAgB,QAAQ,CAAC,YAAY,CAAC,GAAG;AAC5C,aAAO;AAAA,IACR;AAEA,UAAM,QAAQ,YAAY,CAAC;AAG3B,QACC,MAAM,SAAS,uCAAuC,KACnD,MAAM,SAAS,0CAA0C,KACzD,MAAM,SAAS,oDAAoD,KACnE,MAAM,SAAS,uDAAuD,GACxE;AACD,aAAO;AAAA,IACR;AAEA,WAAO,aACJ,CAAC,UAAU,KAAK,KAAK,KAAK,WAAW,KAAK,IAC1C,CAAC,UAAU,KAAK,KAAK;AAAA,EACzB,CAAC,EACA,OAAO,UAAQ,KAAK,KAAK,MAAM,EAAE,EACjC,IAAI,UAAQ;AACZ,QAAI,eAAe;AAClB,aAAO,KAAK,QAAQ,eAAe,EAAE;AAAA,IACtC;AAEA,QAAI,QAAQ;AACX,aAAO,KAAK,QAAQ,kBAAkB,CAAC,GAAG,OAAO,EAAE,QAAQ,IAAI,GAAG,QAAQ,eAAe,GAAG,CAAC,CAAC;AAAA,IAC/F;AAEA,WAAO;AAAA,EACR,CAAC,EACA,KAAK,IAAI;AACZ;",
  "names": []
}
